DIKJSTRA:
https://www.youtube.com/watch?v=GazC3A4OQTE
Start node S
End node E
Other nodes: Other letters

START:
Set distance of all other nodes to INFINITY, we haven't seen them yet.
Priotity queue, shortest paths on top of list.
[S = 0, A = INF, B = INF, K = INF, E = INF :), D = INF].

Check neighbors of S, set neighbors to their distance.
[S = 0, A = 7, B = 2, K = INF, E = INF :), D = INF]. B IS LOWER THAN A, SWAP PLACES
[S = 0, B = 2, A = 7, K = INF, E = INF :), D = INF].
Keep track of predecessors of nodes. [B = 2 S], B's distance is 2 if you go through S. Same with A.

After every neighbor check, sort queue ascending.

When neighbors of S have been checked, put S in "finished pile"

B has lowest value in queue now, let's look at Bs neighbors

B has neighbor A of 3 distance. Update A's distance to Start + cost to B + cost to A. Also update predecessor (A)

B is now done.

BASICALLY:
Sort queue in ascending order
Check neighbors of top queue-boy
Update new distances to nodes
Sort queue, rinse repeat.

####################################################################################################

Question: Chord (5) [Web] 
Assume a fully populated chord circle (in which there is one node per value), with a total of 128 values. Further assume that each node keeps track of its successor, predecessor, and full finger table. Please provide the routing tables of nodes 0, 1, and 5. Be sure to indicate which entries correspond to the successor, predecessor, and full finger table. 

2^m bits in identifier number, 2^7 = 128 in this case.
m entries in finger table.

the ith entry of node n is successor((n+2^(i-1)) mod 2^m)

	[Succ, Pre, FINGERS]
0:	
	[1, 127, (2, 3, 5, 9, 17, 33, 65)]

1:	
	[2, 0, (3, 4, 6, 10, 18, 34, 66)]

5:	
	[6, 4, (7, 8, 10, 14, 22, 38, 70)]
